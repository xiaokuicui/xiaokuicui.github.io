---
layout: post
title: 'Mysql'
categories: mysql
---

##### Mysql 基础架构

``MySql`` 处理请求的全过程分为 5 步:

- 连接器: 当客户端登录的时候，对身份认证和权限进行判断
  可以使用 ``show processlist`` 命令查询连接状态,其中 ``Command`` 含义如下:
    Command|含义
    ------|------
    Query|正在执行的查询
    Sleep|空闲连接，等待客户端发送请求
    locked|正在等待表锁的释放
    sorting result|正在对结果进行排序
    sending data|向客户端返回数据
  - 如果客户端太长时间没有动静，连接器会自动将其断开，由参数``wait_timeout``控制，默认为8小时
  - 长连接是指连接成功后，客户端请求一直使用这个连接
  - 短连接是指每次执行完 sql 请求操作的时候都会断开连接，下次 sql 请求会重新建立连接.
    - 由于短连接一直反复创建连接消耗资源,因此大多数情况下建议选择长连接.但是保持长连接会占用系统内存,被占有的内存等到连接断开后才会释放.有两个解决方案:
      - 定期断开长连接，每隔一段时间或者执行一个占用内存大的查询以后断开连接，从而释放内存，当查询的时候再重新创建连接.
      - 5.7 或者更高的版本，通过执行``mysql_reset_connection``来重新初始化连接。此过程不会重新建立连接，但是会释放占用的内存，将连接恢复到刚刚创立连接的状态
  - 连接过程中的等待时间: ``SHOW VARIABLES LIKE 'connect_timeout';``;
  - 非交互式，连接完成后，使用过程中的等待时间:``show VARIABLES like 'wait_timeout';``;
  - 交互式，连接完成后，使用过程中的等待时间:``SHOW VARIABLES LIKE 'interactive_timeout';``;
- 查询缓存: 执行查询语句的时候，会先查询缓存(8.0 版本以后移除)
  - 查询缓存的失效非常频繁，只要有一个对表的更新操作，这个表上的所有查询缓存都会被清空
  - 因此对更新频繁的场景来说，查询缓存的命中率很低
  - 查询缓存比较适合读多写极少的场景，例如系统配置表
- 分析器: 假设在没有命中的查询缓存的情况下,sql 请求就会来到分析器,分析器负责检查 Sql 语句是否正确,明确 Sql 要完成的功能.
- 优化器: 为 sql 提供优化执行的方案. 例如:选择使用哪个索引、多表关联(join)选择表的连接顺序
- 执行器: 将语句分发到执行引擎执行，返回结果.

##### redo log 和 binlog

1. redo log
   - 包括两部分:redo log buffer(重做日志缓存)容易丢失。redo log file(重做日志文件)持久的.
   - redolog 的大小是固定的，可以通过修改配置参数innodb_log_files_in_group和innodb_log_file_size配置日志文件数量和每个日志文件大小，redolog采用循环写的方式记录，当写到结尾时，会回到开头循环写日志
   - 重做日志文件的大小:``SHOW VARIABLES LIKE 'innodb_log_file_size'``;
   - 指定重做日志文件组中文件的数量，默认2:``SHOW VARIABLES LIKE 'innodb_log_files_in_group'``;

   - 由于每次更新操作都需要直接写入磁盘,整个过程的 IO 成本和查找成本都很高. 所以采用 WAL 技术(Write-Ahead logging):先写日志,在写磁盘.
   - InnoDB 先把记录写到 redolog(需要在哪个数据页做什么修改),并更新内存,在适当的时候(比如:空闲)会把记录写到磁盘里
2. binlog