---
layout: post
title: 数据结构与算法学习笔记
categories: 计算机基础
---

# 知识点图谱

![38ed34a9cf31fd85cf977fc62095b0a4.jpeg](evernotecid://D285E593-984C-44CD-9721-C1CAB3F2B049/appyinxiangcom/21940014/ENResource/p1)

# 是什么？

- 数据结构是一组数据的存储机构。数据结构是为算法服务的.
- 算法是操作数据的一组方法。算法要作用在特定的数据结构之上.

# 学什么？

- 复杂度分析:效率和资源消耗的度量衡(如何更快、更省地存储和处理数据)
- 最常用和最基础的 20 个数据结构与算法:学习它们的来历、特点、适合解决什么问题和实际应用的场景。
- 数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire 树
- 算法: 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

# 怎么学

- 边学边练，适度刷题(每周花 1~2 小时集中攻关三节课涉及的数据结构和算法，全部写出来)
- 多问、多思考、多互动（主动提问、多思考、多互动。在留言区增加自己的留言）
- 给自己设立一个切实可行的目标（自我激励，每次学习完做一篇学习笔记）
- 知识需要沉淀、不要试图一下子掌握所有(沉下心不要浮躁，先把这些基础的数据结构和算法，还有学习方法熟练掌握后，再追求更高层次)

# 1.复杂度分析(上) - 如何分析、统计算法的执行效率和资源消耗

## 1.1 复杂度分析是什么?

1. 数据结构和算法解决的是"如何让计算机更快时间、更省空间"的问题
2. 因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能
3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题,二者统称为复杂度
4. 复杂度描述的是算法执行时间(或占用空间)与数据规模的增长关系

## 1.2 为什么需要复杂度分析?

1. 性能测试(事后统计法)需要依赖执行环境,测试结果会受数据规模的影响
2. 和性能测试(事后统计法)相比,复杂度分析不必依赖执行环境、成本低、效率高、易操作、指导性强、不受数据规模的影响。
3. 掌握复杂度分析,将能编写出性能更优的代码,有利于降低系统开发和维护成本

## 1.3 如何进行复杂度分析?

1. 大 O 表示法: T(n) = O(f(n)

  - 公式中的 O 表示算法的执行时间与每行代码的执行次数成正比,其中 T(n) 表示算法执行总时间,f(n) 表示每行代码执行总次数,而 n 往往表示数据的规模。
  - 大 O 时间复杂度并不表示代码的具体执行时间,而是表示代码(算法)的执行时间随数据规模增长的变化趋势,也叫做**渐进时间复杂度**,简称**时间复杂度**.
  - 当 n 很大时,公式中的低阶、常量、系数三部分并不影响增长趋势,所以可以忽略,只需记录一个最大量级就可以了。

2. 复杂度分析法则

  - 分析一个算法、一段代码的时间复杂度的时候,只需关注循环次数最多的那段代码就可以了
  - 加法法则: 总的时间复杂度等于量级最大的那段代码的复杂度。
  - 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。比如: 嵌套循环

## 1.4 常用的复杂度级别

1. 多项式阶:

  - 随着数据规模的增长,算法的执行时间和空间占用,按照多项式的比例增长。包括:常熟阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n²)、立方阶 O(n³)。

2. 非多项式阶:

  - 随着数据规模的增长,算法的执行时间和空间占用暴增,这类算法性能极差。包括指数阶 O(2^n)、阶乘阶 O(n!)。

## 1.5 空间复杂度

1. 表示代码(算法)的存储空间随数据规模增长的变化趋势,也叫做**渐进空间复杂度**,也叫做**空间复杂度**。
2. 常见的空间复杂度就是 O(1)、O(n)、O(n²),像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

# 2.复杂度分析(下) - 浅析最好、最坏、平均、均摊时间复杂度

1. 最坏时间复杂度: 代码在最坏情况下执行的时间复杂度
2. 最好时间复杂度: 代码在最好情况下执行的时间复杂度
3. 平均时间复杂度: 代码在所有情况下执行的次数的加权平均值
4. 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度,个别情况是高级别复杂度且发生具有时序关系时,可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度.

# 3.数组

![数组](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/array/array.jpg)

- 数组(Array)是一种线性表数据结构,它用一组连续的内存空间来存储一组具有相同类型的数据.
- 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。
- 在数组中插入和删除一个数据,为了保证内存数据的连续性,需要做大量的搬移操作,所以时间复杂度是 O(n).
- 数组通过寻址公式 `a[i]_address = base_adress + i * data_type_size` 来实现根据下标随机访问元素的.其中 base_address 为数组的首地址,data_type_size 表示数组中每个元素的大小.
- 数组支持随机访问,根据下标随机访问的时间复杂度是 O(1).
- 数组简单易用,在实现上使用的是连续的内存空间,可以借助 CPU 的缓存机制,预读数组中的数据,所以访问效果更高。而链表在内存中并不是连续存储,所以对 CPU 缓存不友好,没办法有效预读。

  CPU 从内存中读取数据的时会先把读取到的数据加载到 CPU 缓存中。而 CPU 每次从内存读取数据并不是只读取那个特定要访问的地址,而是读取一个数据块并保存到 CPU 缓存中,然后下次访问内存数据的时候就会先从 CPU 缓存开始查找,如果找到就不需要在从内存中取。因为数组的内存空间是连续的,所以加载某个下标的时候就可以把后几个下标元素也加载到 CPU 缓存中。

# 4.链表

![链表和数组内存分布](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpg)

> 链表中的数据并非连续存储的,所以插入和删除的时候不需要为了保证内存的连续性而做大量的搬移操作,所以时间复杂度是 O(1) .链表查找的时候需要根据指针一个节点一个节点的依次遍历,直到找到相应的节点.时间复杂度是 O(n).

- ![单链表](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg)

- ![双向链表](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg)

- ![循环链表](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg)

  - 循环链表是一种特殊的单链表,优点是从链尾到链头非常方便.当处理的数据具有环型结构特点时,就特别适合采用循环链表。比如著名的[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)

- ![双向循环链表](https://raw.githubusercontent.com/xiaokuicui/xiaokuicui.github.io/master/assets/images/data/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg)

- 如何用链表实现 LRU (最近最少使用)缓存淘汰算法?

  维护一个有序的单链表,越靠近尾部的节点是越早之前访问的.当有一个新的数据被访问时,从链表头开始顺序遍历链表.

  1. 如果此数据之前已经被缓存在链表中了,遍历得到这个数据对应的节点,并将其从原来的位置删除并插入链表的头部.
  2. 如果此数据没有缓存在链表中,分为两种情况:

    - 如果此时缓存未满,则将此结点直接插入链表的头部.
    - 如果此时缓存已满,则删除链表尾部的结点,将新的数据插入链表的头部.

- 如何判断一个字符串是否是回文字符串,如果字符串是通过一个单链表来存储的,如何判断该字符串是回文串?

# 5.栈

# 6.队列

# 7.递归

# 8.排序

# 9.线性排序
